/*
 * Smobilpay S3P API
 * Smobilpay Third Party API FOR PAYMENT COLLECTIONS
 *
 * OpenAPI spec version: 3.0.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.maviance.s3pjavaclient.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.math.BigDecimal;
import org.threeten.bp.LocalDate;
/**
 * Subscription
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-02-18T05:58:05.742+01:00[Africa/Douala]")
public class Subscription {
  @SerializedName("serviceNumber")
  private String serviceNumber = null;

  @SerializedName("serviceid")
  private String serviceid = null;

  @SerializedName("merchant")
  private String merchant = null;

  @SerializedName("payItemId")
  private String payItemId = null;

  @SerializedName("payItemDescr")
  private String payItemDescr = null;

  /**
   * &#x27;Supported amount type for the payment of this subscription:&#x27; &#x27;\&quot;FIXED\&quot; -&gt; subscription needs to be paid in full, (Payment amount &#x3D; subscription amount provided in \&quot;amount\&quot;)&#x27; &#x27;\&quot;PARTIAL\&quot; -&gt; Partial subscription amount can be paid. (Payment amount &lt; subscription amount provided in \&quot;amount\&quot;))&#x27; &#x27;\&quot;OVERPAY\&quot; -&gt; More than the actual subscription amount owed can be paid. (Payment amount &gt; subscription amount provided in \&quot;amount\&quot;). Overpayments are subject to country specific regulations and may be limited to a certain threshold. &#x27; &#x27;\&quot;CUSTOM\&quot; -&gt; Amount can be freely entered, independent of subscription amount provided in \&quot;amount\&quot;&#x27; 
   */
  @JsonAdapter(AmountTypeEnum.Adapter.class)
  public enum AmountTypeEnum {
    FIXED("FIXED"),
    CUSTOM("CUSTOM"),
    PARTIAL("PARTIAL"),
    OVERPAY("OVERPAY");

    private String value;

    AmountTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AmountTypeEnum fromValue(String text) {
      for (AmountTypeEnum b : AmountTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AmountTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AmountTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AmountTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextObject();
        return AmountTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("amountType")
  private AmountTypeEnum amountType = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("localCur")
  private String localCur = null;

  @SerializedName("amountLocalCur")
  private Float amountLocalCur = null;

  @SerializedName("customerReference")
  private String customerReference = null;

  @SerializedName("customerName")
  private String customerName = null;

  @SerializedName("customerNumber")
  private String customerNumber = null;

  @SerializedName("startDate")
  private LocalDate startDate = null;

  @SerializedName("dueDate")
  private LocalDate dueDate = null;

  @SerializedName("endDate")
  private LocalDate endDate = null;

  @SerializedName("optStrg")
  private String optStrg = null;

  @SerializedName("optNmb")
  private BigDecimal optNmb = null;

  public Subscription serviceNumber(String serviceNumber) {
    this.serviceNumber = serviceNumber;
    return this;
  }

   /**
   * service number with merchant (e.g. policy number with an insurance company or tax number for a governmental institution)
   * @return serviceNumber
  **/
  @Schema(required = true, description = "service number with merchant (e.g. policy number with an insurance company or tax number for a governmental institution)")
  public String getServiceNumber() {
    return serviceNumber;
  }

  public void setServiceNumber(String serviceNumber) {
    this.serviceNumber = serviceNumber;
  }

  public Subscription serviceid(String serviceid) {
    this.serviceid = serviceid;
    return this;
  }

   /**
   * Unique Service Identifier
   * @return serviceid
  **/
  @Schema(required = true, description = "Unique Service Identifier")
  public String getServiceid() {
    return serviceid;
  }

  public void setServiceid(String serviceid) {
    this.serviceid = serviceid;
  }

  public Subscription merchant(String merchant) {
    this.merchant = merchant;
    return this;
  }

   /**
   * Unique merchant code
   * @return merchant
  **/
  @Schema(required = true, description = "Unique merchant code")
  public String getMerchant() {
    return merchant;
  }

  public void setMerchant(String merchant) {
    this.merchant = merchant;
  }

  public Subscription payItemId(String payItemId) {
    this.payItemId = payItemId;
    return this;
  }

   /**
   * Unique Payment Item ID identifying the subscription
   * @return payItemId
  **/
  @Schema(required = true, description = "Unique Payment Item ID identifying the subscription")
  public String getPayItemId() {
    return payItemId;
  }

  public void setPayItemId(String payItemId) {
    this.payItemId = payItemId;
  }

  public Subscription payItemDescr(String payItemDescr) {
    this.payItemDescr = payItemDescr;
    return this;
  }

   /**
   * Optional description about payment details
   * @return payItemDescr
  **/
  @Schema(description = "Optional description about payment details")
  public String getPayItemDescr() {
    return payItemDescr;
  }

  public void setPayItemDescr(String payItemDescr) {
    this.payItemDescr = payItemDescr;
  }

  public Subscription amountType(AmountTypeEnum amountType) {
    this.amountType = amountType;
    return this;
  }

   /**
   * &#x27;Supported amount type for the payment of this subscription:&#x27; &#x27;\&quot;FIXED\&quot; -&gt; subscription needs to be paid in full, (Payment amount &#x3D; subscription amount provided in \&quot;amount\&quot;)&#x27; &#x27;\&quot;PARTIAL\&quot; -&gt; Partial subscription amount can be paid. (Payment amount &lt; subscription amount provided in \&quot;amount\&quot;))&#x27; &#x27;\&quot;OVERPAY\&quot; -&gt; More than the actual subscription amount owed can be paid. (Payment amount &gt; subscription amount provided in \&quot;amount\&quot;). Overpayments are subject to country specific regulations and may be limited to a certain threshold. &#x27; &#x27;\&quot;CUSTOM\&quot; -&gt; Amount can be freely entered, independent of subscription amount provided in \&quot;amount\&quot;&#x27; 
   * @return amountType
  **/
  @Schema(required = true, description = "'Supported amount type for the payment of this subscription:' '\"FIXED\" -> subscription needs to be paid in full, (Payment amount = subscription amount provided in \"amount\")' '\"PARTIAL\" -> Partial subscription amount can be paid. (Payment amount < subscription amount provided in \"amount\"))' '\"OVERPAY\" -> More than the actual subscription amount owed can be paid. (Payment amount > subscription amount provided in \"amount\"). Overpayments are subject to country specific regulations and may be limited to a certain threshold. ' '\"CUSTOM\" -> Amount can be freely entered, independent of subscription amount provided in \"amount\"' ")
  public AmountTypeEnum getAmountType() {
    return amountType;
  }

  public void setAmountType(AmountTypeEnum amountType) {
    this.amountType = amountType;
  }

  public Subscription name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Title/Name of subscription
   * @return name
  **/
  @Schema(required = true, description = "Title/Name of subscription")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Subscription localCur(String localCur) {
    this.localCur = localCur;
    return this;
  }

   /**
   * Local currency of service. (Format: ISO 4217)
   * @return localCur
  **/
  @Schema(required = true, description = "Local currency of service. (Format: ISO 4217)")
  public String getLocalCur() {
    return localCur;
  }

  public void setLocalCur(String localCur) {
    this.localCur = localCur;
  }

  public Subscription amountLocalCur(Float amountLocalCur) {
    this.amountLocalCur = amountLocalCur;
    return this;
  }

   /**
   * Payable amount in local currency
   * @return amountLocalCur
  **/
  @Schema(required = true, description = "Payable amount in local currency")
  public Float getAmountLocalCur() {
    return amountLocalCur;
  }

  public void setAmountLocalCur(Float amountLocalCur) {
    this.amountLocalCur = amountLocalCur;
  }

  public Subscription customerReference(String customerReference) {
    this.customerReference = customerReference;
    return this;
  }

   /**
   * Optional Customer reference
   * @return customerReference
  **/
  @Schema(description = "Optional Customer reference")
  public String getCustomerReference() {
    return customerReference;
  }

  public void setCustomerReference(String customerReference) {
    this.customerReference = customerReference;
  }

  public Subscription customerName(String customerName) {
    this.customerName = customerName;
    return this;
  }

   /**
   * Customer Name
   * @return customerName
  **/
  @Schema(description = "Customer Name")
  public String getCustomerName() {
    return customerName;
  }

  public void setCustomerName(String customerName) {
    this.customerName = customerName;
  }

  public Subscription customerNumber(String customerNumber) {
    this.customerNumber = customerNumber;
    return this;
  }

   /**
   * Optional Customer number with merchant
   * @return customerNumber
  **/
  @Schema(description = "Optional Customer number with merchant")
  public String getCustomerNumber() {
    return customerNumber;
  }

  public void setCustomerNumber(String customerNumber) {
    this.customerNumber = customerNumber;
  }

  public Subscription startDate(LocalDate startDate) {
    this.startDate = startDate;
    return this;
  }

   /**
   * Optional start date (Format: ISO 8601)
   * @return startDate
  **/
  @Schema(description = "Optional start date (Format: ISO 8601)")
  public LocalDate getStartDate() {
    return startDate;
  }

  public void setStartDate(LocalDate startDate) {
    this.startDate = startDate;
  }

  public Subscription dueDate(LocalDate dueDate) {
    this.dueDate = dueDate;
    return this;
  }

   /**
   * Optional due due date (Format: ISO 8601)
   * @return dueDate
  **/
  @Schema(description = "Optional due due date (Format: ISO 8601)")
  public LocalDate getDueDate() {
    return dueDate;
  }

  public void setDueDate(LocalDate dueDate) {
    this.dueDate = dueDate;
  }

  public Subscription endDate(LocalDate endDate) {
    this.endDate = endDate;
    return this;
  }

   /**
   * Optional end date (Format: ISO 8601)
   * @return endDate
  **/
  @Schema(description = "Optional end date (Format: ISO 8601)")
  public LocalDate getEndDate() {
    return endDate;
  }

  public void setEndDate(LocalDate endDate) {
    this.endDate = endDate;
  }

  public Subscription optStrg(String optStrg) {
    this.optStrg = optStrg;
    return this;
  }

   /**
   * Optional string field to carry additional information
   * @return optStrg
  **/
  @Schema(description = "Optional string field to carry additional information")
  public String getOptStrg() {
    return optStrg;
  }

  public void setOptStrg(String optStrg) {
    this.optStrg = optStrg;
  }

  public Subscription optNmb(BigDecimal optNmb) {
    this.optNmb = optNmb;
    return this;
  }

   /**
   * Optional number field to carry additional information
   * @return optNmb
  **/
  @Schema(description = "Optional number field to carry additional information")
  public BigDecimal getOptNmb() {
    return optNmb;
  }

  public void setOptNmb(BigDecimal optNmb) {
    this.optNmb = optNmb;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Subscription subscription = (Subscription) o;
    return Objects.equals(this.serviceNumber, subscription.serviceNumber) &&
        Objects.equals(this.serviceid, subscription.serviceid) &&
        Objects.equals(this.merchant, subscription.merchant) &&
        Objects.equals(this.payItemId, subscription.payItemId) &&
        Objects.equals(this.payItemDescr, subscription.payItemDescr) &&
        Objects.equals(this.amountType, subscription.amountType) &&
        Objects.equals(this.name, subscription.name) &&
        Objects.equals(this.localCur, subscription.localCur) &&
        Objects.equals(this.amountLocalCur, subscription.amountLocalCur) &&
        Objects.equals(this.customerReference, subscription.customerReference) &&
        Objects.equals(this.customerName, subscription.customerName) &&
        Objects.equals(this.customerNumber, subscription.customerNumber) &&
        Objects.equals(this.startDate, subscription.startDate) &&
        Objects.equals(this.dueDate, subscription.dueDate) &&
        Objects.equals(this.endDate, subscription.endDate) &&
        Objects.equals(this.optStrg, subscription.optStrg) &&
        Objects.equals(this.optNmb, subscription.optNmb);
  }

  @Override
  public int hashCode() {
    return Objects.hash(serviceNumber, serviceid, merchant, payItemId, payItemDescr, amountType, name, localCur, amountLocalCur, customerReference, customerName, customerNumber, startDate, dueDate, endDate, optStrg, optNmb);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Subscription {\n");
    
    sb.append("    serviceNumber: ").append(toIndentedString(serviceNumber)).append("\n");
    sb.append("    serviceid: ").append(toIndentedString(serviceid)).append("\n");
    sb.append("    merchant: ").append(toIndentedString(merchant)).append("\n");
    sb.append("    payItemId: ").append(toIndentedString(payItemId)).append("\n");
    sb.append("    payItemDescr: ").append(toIndentedString(payItemDescr)).append("\n");
    sb.append("    amountType: ").append(toIndentedString(amountType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    localCur: ").append(toIndentedString(localCur)).append("\n");
    sb.append("    amountLocalCur: ").append(toIndentedString(amountLocalCur)).append("\n");
    sb.append("    customerReference: ").append(toIndentedString(customerReference)).append("\n");
    sb.append("    customerName: ").append(toIndentedString(customerName)).append("\n");
    sb.append("    customerNumber: ").append(toIndentedString(customerNumber)).append("\n");
    sb.append("    startDate: ").append(toIndentedString(startDate)).append("\n");
    sb.append("    dueDate: ").append(toIndentedString(dueDate)).append("\n");
    sb.append("    endDate: ").append(toIndentedString(endDate)).append("\n");
    sb.append("    optStrg: ").append(toIndentedString(optStrg)).append("\n");
    sb.append("    optNmb: ").append(toIndentedString(optNmb)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
